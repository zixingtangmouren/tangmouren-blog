<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>唐某人的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="这是唐某人的技术博客，用于记录平日里学习JS，Vue，Webpack，React的相关心得。">
    
    <link rel="preload" href="/tangmouren/assets/css/0.styles.e64195ee.css" as="style"><link rel="preload" href="/tangmouren/assets/js/app.398b06f8.js" as="script"><link rel="preload" href="/tangmouren/assets/js/2.f18c010c.js" as="script"><link rel="preload" href="/tangmouren/assets/js/11.4dd24b27.js" as="script"><link rel="prefetch" href="/tangmouren/assets/js/10.fbff40b9.js"><link rel="prefetch" href="/tangmouren/assets/js/12.eed0a89c.js"><link rel="prefetch" href="/tangmouren/assets/js/13.353df724.js"><link rel="prefetch" href="/tangmouren/assets/js/3.f34435cc.js"><link rel="prefetch" href="/tangmouren/assets/js/4.09ee8a39.js"><link rel="prefetch" href="/tangmouren/assets/js/5.18616f39.js"><link rel="prefetch" href="/tangmouren/assets/js/6.498ab014.js"><link rel="prefetch" href="/tangmouren/assets/js/7.ec13ad86.js"><link rel="prefetch" href="/tangmouren/assets/js/8.021501ea.js"><link rel="prefetch" href="/tangmouren/assets/js/9.8c7c913b.js">
    <link rel="stylesheet" href="/tangmouren/assets/css/0.styles.e64195ee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/tangmouren/" class="home-link router-link-active"><!----> <span class="site-name">唐某人的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/tangmouren/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/tangmouren/JS/" class="nav-link">
  JS
</a></div><div class="nav-item"><a href="/tangmouren/Vue/" class="nav-link router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/tangmouren/Webpack/" class="nav-link">
  Webpack
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/tangmouren/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/tangmouren/JS/" class="nav-link">
  JS
</a></div><div class="nav-item"><a href="/tangmouren/Vue/" class="nav-link router-link-active">
  Vue
</a></div><div class="nav-item"><a href="/tangmouren/Webpack/" class="nav-link">
  Webpack
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Vue原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tangmouren/Vue/" aria-current="page" class="sidebar-link">开始</a></li><li><a href="/tangmouren/Vue/vue3组件通信.html" class="sidebar-link">vue3组件通信</a></li><li><a href="/tangmouren/Vue/实现一个简单的Vue3框架.html" class="active sidebar-link">实现一个简单的Vue3框架</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tangmouren/Vue/实现一个简单的Vue3框架.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/tangmouren/Vue/实现一个简单的Vue3框架.html#要做什么" class="sidebar-link">要做什么</a></li><li class="sidebar-sub-header"><a href="/tangmouren/Vue/实现一个简单的Vue3框架.html#初始化选项-setup" class="sidebar-link">初始化选项 setup</a></li><li class="sidebar-sub-header"><a href="/tangmouren/Vue/实现一个简单的Vue3框架.html#响应式核心-reactive-函数" class="sidebar-link">响应式核心 reactive 函数</a></li><li class="sidebar-sub-header"><a href="/tangmouren/Vue/实现一个简单的Vue3框架.html#实现异步队列的机制" class="sidebar-link">实现异步队列的机制</a></li><li class="sidebar-sub-header"><a href="/tangmouren/Vue/实现一个简单的Vue3框架.html#实现-watch" class="sidebar-link">实现 watch</a></li><li class="sidebar-sub-header"><a href="/tangmouren/Vue/实现一个简单的Vue3框架.html#实现-computed" class="sidebar-link">实现 computed</a></li><li class="sidebar-sub-header"><a href="/tangmouren/Vue/实现一个简单的Vue3框架.html#实现-watcheffect" class="sidebar-link">实现 watchEffect</a></li><li class="sidebar-sub-header"><a href="/tangmouren/Vue/实现一个简单的Vue3框架.html#最后" class="sidebar-link">最后</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="实现一个简单的-vue3"><a href="#实现一个简单的-vue3" class="header-anchor">#</a> 实现一个简单的 Vue3</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>最近自己写了一个简易版的 Vue3 玩一玩，当然啦，里面没有 patch 和编译的部分（因为能力有限）😂，所以像分享一下自己在这个过程中学到的东西。该篇主要是以如何实现一个简单 Vue3 的方式，来讲解源码的设计和基本原理。</p> <h2 id="要做什么"><a href="#要做什么" class="header-anchor">#</a> 要做什么</h2> <p>在做之前，先想一下要做啥，所以简单列了一个清单：</p> <ol><li>搞懂 setup 选项</li> <li>实现响应式核心 reactive 函数</li> <li>实现异步队列的机制</li> <li>实现 effect 函数</li> <li>实现 watch， computed，watchEffect 函数</li></ol> <p>这些是我在大致看了源码之后，总结出来的 Vue3 主要部分，也是我们日常开发会经常接触到的部分。接下来，我们就来完成这些清单，并在一步步实现中，搞懂 Vue3 的大致原理。</p> <h2 id="初始化选项-setup"><a href="#初始化选项-setup" class="header-anchor">#</a> 初始化选项 setup</h2> <p>这里我先来看一下 Vue3 中 setup 的用法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h1 @click<span class="token operator">=</span><span class="token string">&quot;onClick&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> msg <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> state<span class="token punctuation">.</span>name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> state<span class="token punctuation">.</span>age <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> doubleAge <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> defineComponent<span class="token punctuation">,</span> reactive<span class="token punctuation">,</span> onBeforeMount<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'App'</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    msg<span class="token operator">:</span> String<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      name<span class="token operator">:</span> <span class="token string">'tangmouren'</span><span class="token punctuation">,</span>
      age<span class="token operator">:</span> <span class="token number">18</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">const</span> doubleAge <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>age <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>

    <span class="token keyword">const</span> <span class="token function-variable function">onClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">onBeforeMount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>msg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">,</span>
      doubleAge<span class="token punctuation">,</span>
      onClick
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>我们来分析它是如何运行的。</p> <p>首先它是一个函数。它会将组件中需要的数据和方法通过一个对象返回。这个有点像 Vue2 中的 data 选项，用函数返回一个数据对象，其实它们的道理一致，都是将组件需要的东西 return 出去。所以在组件初始化时会执行这些函数，获取返回的对象并进行相关处理，最后统一挂载至组件实例上。</p> <p>这里可以简单实现一下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Vue</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> setup <span class="token punctuation">}</span> <span class="token operator">=</span> options
  <span class="token keyword">const</span> setupResult <span class="token operator">=</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>ctx <span class="token operator">=</span> setupResult
<span class="token punctuation">}</span>
</code></pre></div><p>然后组件渲染的时候就可以通过这个 ctx 访问到这些数据和方法了，这里展示一个 Vue3 模板编译的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h1 @click<span class="token operator">=</span><span class="token string">&quot;onClick&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> msg <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> state<span class="token punctuation">.</span>name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> state<span class="token punctuation">.</span>age <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> doubleAge <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

  <span class="token comment">// 会被编译成：</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">_ctx<span class="token punctuation">,</span> _cache<span class="token punctuation">,</span> $props<span class="token punctuation">,</span> $setup<span class="token punctuation">,</span> $data<span class="token punctuation">,</span> $options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">_openBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_createBlock</span><span class="token punctuation">(</span><span class="token string">&quot;div&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token function">_createVNode</span><span class="token punctuation">(</span><span class="token string">&quot;h1&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> onClick<span class="token operator">:</span> _ctx<span class="token punctuation">.</span>onClick <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">_toDisplayString</span><span class="token punctuation">(</span>_ctx<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">9</span> <span class="token comment">/* TEXT, PROPS */</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&quot;onClick&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">_createVNode</span><span class="token punctuation">(</span><span class="token string">&quot;h2&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">_toDisplayString</span><span class="token punctuation">(</span>_ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">_createVNode</span><span class="token punctuation">(</span><span class="token string">&quot;h2&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">_toDisplayString</span><span class="token punctuation">(</span>_ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">_createVNode</span><span class="token punctuation">(</span><span class="token string">&quot;h2&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token function">_toDisplayString</span><span class="token punctuation">(</span>_ctx<span class="token punctuation">.</span>doubleAge<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* TEXT */</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="响应式核心-reactive-函数"><a href="#响应式核心-reactive-函数" class="header-anchor">#</a> 响应式核心 reactive 函数</h2> <p>前面咱们已经小试身手的写了几行代码了，这个“宏伟”的工程已经开始了。接下来，就是 Vue 中最为核心的部分，也是我认为任何一个 Vue 开发者必须懂的部分。</p> <h3 id="老生常谈的响应式原理"><a href="#老生常谈的响应式原理" class="header-anchor">#</a> 老生常谈的响应式原理</h3> <p>先来梳理一下 Vue 一个关键的理念 --- 响应式设计。在响应式原理中最重要的三要素，就 <strong>Watcher， Dep，Observer。</strong> 正是由这三个要素实现了观察者模式（发布者/订阅者模式）。那这个模式，在 Vue2/Vue3 中是如何工作的呢，咱们先来搞懂这几个问题：</p> <p>在框架中，谁是发布者，谁是订阅者：<strong>对数据（data）进行拦截的那个对象，就是发布者。包含一个任务（函数）的对象/函数，就是订阅者(Vue2 是 Watcher，Vue3 是 Effect)。</strong></p> <p>发布者和订阅者之间的关系：<strong>发布者会去收集相关的订阅者，一旦发布者有动作，就会通知收集到的订阅者执行任务。</strong></p> <p>发布者是如何收集订阅者的：<strong>在渲染时会创建 VNode 并读取数据，所以发布者的某个数据一旦被访问，它就会把当前激活的订阅者存到对应的 Dep 中（这过程叫依赖收集）。</strong></p> <p>关于依赖收集在读取数据的过程，可以看一下上面关于<code>template</code>编译成<code>render</code>函数的代码（这个编译过程是由 vue-loader 处理的）。因为创建<code>VNode</code>需要读取相关数据，所以一旦读取数据就会触发对应的依赖收集。</p> <h3 id="vue2-和-vue3-在实现上的差异"><a href="#vue2-和-vue3-在实现上的差异" class="header-anchor">#</a> Vue2 和 Vue3 在实现上的差异</h3> <p>Vue3 在响应式设计上肯定是不会发生太多变化的，所以大致逻辑基本跟 Vue2 一致，换汤不换药。但是在 Vue3 的部分核心逻辑上，还是做出了一定的优化和改变。</p> <p>主要如下：</p> <ol><li>在 Vue2 使用的<code>Object.defineProperty</code>实现的数据拦截，而在 Vue3 中则是采用<code>Proxy</code>去进行数据的代理。</li> <li><code>Dep</code>也不再存储在闭包中，而是使用<code>WeakMap，Map，Set</code>这些数据结构来全局的存储。</li> <li>之前是采用<code>Watcher</code>去实现订阅者，在 Vue3 则是采用<code>effect</code>这种副作用函数的形式。所以在依赖收集的过程中，收集的不再是<code>Watcher</code>而是<code>effect</code>函数。</li></ol> <h3 id="实现-observer"><a href="#实现-observer" class="header-anchor">#</a> 实现 Observer</h3> <p>理清原理，可以开始干正事了。首先来实现三大要素中的第一位选手---观察者。</p> <p>它有什么功能：</p> <ol><li>对一个数据进行代理，拦截读写增删等操作（Proxy 不仅仅只能拦截读和写，有兴趣的可以去 MDN 详细去了解一下，本篇只考虑读写的情况）</li> <li>被读的时候，收集当前激活的<code>effect</code>函数存入<code>Dep</code>中</li> <li>当被修改时，执行<code>Dep</code>中所有的<code>effect</code>函数</li></ol> <p>在<code>Composition API</code>中，提供了一个<code>reactive</code>函数来实现 Vue 的响应式系统，将传入的对象用 proxy 进行响应式处理，并将其对象的代理返回。所以这里先来写一个<code>reactive</code>函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// proxy对应的handler</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
  get<span class="token operator">:</span> getter<span class="token punctuation">,</span>
  set<span class="token operator">:</span> setter
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> target <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> target

  <span class="token keyword">return</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createReactiveObject</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 对当前这个对象进行响应式的处理并返回代理</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里不难看出，创建的发布者就是一个 Proxy。Proxy 会对目标对象进行访问拦截，因为目前只考虑对数据进行读和写的情况，所以只实现 set 和 get 的具体逻辑。</p> <h4 id="get"><a href="#get" class="header-anchor">#</a> get</h4> <p>get 的主要截逻辑是数据被访问时，先读取目标对象的值，再为当访问的 key 收集<code>activeEffect</code>并存入对应<code>Dep</code>中。</p> <p>这里先来实现读取值的逻辑（提示：留意一下访问的值是对象的时候）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 当前激活的effect</span>
<span class="token keyword">let</span> activeEffect

<span class="token comment">// 读取拦截</span>
<span class="token keyword">function</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 读取目标对象对应属性的值</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token comment">// 让这个key收集当前激活的effect</span>
  <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>

  <span class="token comment">// 这里要考虑访问的属性可能是对象的情况</span>
  <span class="token comment">// 需要进一步进行响应式处理</span>
  <span class="token comment">// 这里也是Vue3的一个优化，下文会细说</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reactive</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre></div><p>重点是 track 的逻辑，它是依赖收集的关键，它会根据当前对象被访问的 key 找到对应 dep，然后将当前的<code>activeEffect</code>收集进去。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 收集依赖</span>
<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>activeEffect <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 找到当前对象的dep集合</span>
  <span class="token keyword">let</span> depsMap <span class="token operator">=</span> targetMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
  <span class="token comment">// 如果没有就创建一个新的dep集合</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    targetMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 每个key都有自己对应的dep</span>
  <span class="token keyword">let</span> dep <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dep<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 保存当前的activeEffect</span>
    dep<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>activeEffect<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的代码就基本实现了数据被访问时收集依赖的功能。但是，还有两个点需要说明一下：</p> <ol><li>一个是代码中用到的<code>targetMap, depsMap, dep</code>这几个数据结构</li> <li>访问的值是一个对象的时候的处理</li></ol> <p>先来看第一个点，前面也说到，Vue3 在对 Dep 的存储进行了改变，所以你先暂时认为这几个数据结构只是用来储存和查找 dep 的。dep 的实现，将放在后面来讲解。</p> <p>然后是第二点，这个是一个<strong>重点</strong>。</p> <p>为什么当访问的 key 对应的 value 是一个对象时，要做不一样的处理呢？</p> <p>这里说一下 Vue2 是如何对一个对象进行响应式处理。 Vue2 它提供了一个<code>data</code>选项，这个选项一般都是一个对象，或者是返回一个对象的函数，在 Vue2 中响应式处理会将<code>data</code>提供的这个对象去深度的遍历，一旦某个属性的值是一个对象就会继续往下递归，去使用<code>Object.defineProperty</code>这 API 去进行拦截处理。大致实现如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">reactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果是一个对象，继续递归处理</span>
    <span class="token function">observer</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种方式，这就会存在两个很大的性能问题：</p> <ol><li><p>如果对象的层次很深，那递归的过程是很消耗性能。第一使用<code>Object.defineProperty</code>这个 API 需要遍历对象的每一个 key 进行处理，第二如果这个 key 对应的值又是一个对象，那么又需要进行递归的遍历处理。</p></li> <li><p>这样全面的递归响应式处理，还会产生一个问题，那就是如果对象的层次很深，但是里面很多的属性都没有在<code>template</code>中使用到，那给这些没有使用到的 key 增加的依赖收集，和通知订阅者的能力，就成了毫无意义的操作。</p></li></ol> <p>这里说一个我在工作中看到的例子：</p> <p>在工作中经常会使用到一些第三方框架，像<code>Echart, Antv</code>这些数据可视化框架，还有<code>BMap, AMap</code>这些地图框架。但是我发现我们公司有的小伙伴，就会不小心做一个这样的事情，比如他在组件中使用一个可视化图表：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Chart <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@antv/g2'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'About'</span><span class="token punctuation">,</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      barChart<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里直接将创建好的图表实例赋值给了data里面的barChart</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>barChart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Chart</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      container<span class="token operator">:</span> <span class="token string">'container'</span><span class="token punctuation">,</span>
      width<span class="token operator">:</span> <span class="token number">600</span><span class="token punctuation">,</span>
      height<span class="token operator">:</span> <span class="token number">300</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// 这里来输出看一下</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>barChart<span class="token punctuation">)</span>

    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> year<span class="token operator">:</span> <span class="token string">'1951 年'</span><span class="token punctuation">,</span> sales<span class="token operator">:</span> <span class="token number">38</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> year<span class="token operator">:</span> <span class="token string">'1952 年'</span><span class="token punctuation">,</span> sales<span class="token operator">:</span> <span class="token number">52</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> year<span class="token operator">:</span> <span class="token string">'1956 年'</span><span class="token punctuation">,</span> sales<span class="token operator">:</span> <span class="token number">61</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> year<span class="token operator">:</span> <span class="token string">'1957 年'</span><span class="token punctuation">,</span> sales<span class="token operator">:</span> <span class="token number">145</span> <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>barChart<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>barChart<span class="token punctuation">.</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token string">'sales'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      nice<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>barChart<span class="token punctuation">.</span><span class="token function">tooltip</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      showMarkers<span class="token operator">:</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>barChart<span class="token punctuation">.</span><span class="token function">interaction</span><span class="token punctuation">(</span><span class="token string">'active-region'</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>barChart<span class="token punctuation">.</span><span class="token function">interval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token string">'year*sales'</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>barChart<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>看似这样的写法好像没什么问题，但是此时我们来看一下<code>barChart</code>的输出：</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5f39849256841d4a0343c649885acf7~tplv-k3u1fbpfcp-watermark.image" alt="1619682666(1).jpg"></p> <p>你可以发现，这个对象图表实例中所有的属性都被进行了响应式处理。你可以想一下，对这么庞大的一个对象进行递归的响应式处理，然后里面的数据在页面上一个都用不到，这难道不是一种性能的浪费吗？当然这也只是举一个例子，我相信大部分的人应该不会犯这种错误，因为如果不需要响应式的数据，也没有必要写在<code>data</code>中。</p> <p>但是在 Vue3 中响应式处理的方式就有所不同，<code>reactive</code>并不会一开始就进行深度的处理，而是只对第一层进行代理。对于深层的对象，它的响应式处理是发生在 get 中。也就是说，如果深层对象的没有被访问，它就永远不会被响应式处理的，这种做法就大大提升了性能，节省了不必要的运行开销。</p> <p>举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token comment">// 在template中</span>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> state<span class="token punctuation">.</span>num <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span> state<span class="token punctuation">.</span>age <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>


<span class="token comment">// 在setup中声明一个响应式对象</span>
 <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    num<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    person<span class="token operator">:</span> <span class="token punctuation">{</span>
      a<span class="token operator">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>因为在模板中没有访问<code>state.person.a</code>，所有<code>person</code>这个对象不会被处理成响应式，就算你如何修改它的值，也不会触发什么事件。</p> <h4 id="set"><a href="#set" class="header-anchor">#</a> set</h4> <p>依赖收集的能力已经实现了，现在再来搞定通知订阅者的逻辑。因为发布者已经把相关的订阅者收集到对应的 dep 队列里面了，所以通知的逻辑，无非就是找到对应的 dep 然后逐一取出里面<code>effect</code>函数去执行。</p> <p>代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">setter</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 修改值</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
  <span class="token comment">// 触发收集到的effect的执行</span>
  <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 找到dep集合</span>
  <span class="token keyword">const</span> depsMap <span class="token operator">=</span> targetMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token keyword">return</span>

  <span class="token comment">// 找到对应的dep</span>
  <span class="token keyword">const</span> dep <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>

  dep<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effect</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果effect存在一个调度的机制，就使用这个调度的方式去执行</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>options<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      effect<span class="token punctuation">.</span>options<span class="token punctuation">.</span><span class="token function">scheduler</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 直接执行这个`effect`</span>
      <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个 set 执行过程就是先修改值，然后执行 trigger 去找到当前 key 对应的 dep，最后遍历执行 dep 中的订阅者<code>effect</code>。</p> <h4 id="简单试一下"><a href="#简单试一下" class="header-anchor">#</a> 简单试一下</h4> <p>上面响应式处理的大部分逻辑已经实现了，现在来简单测试一下。我们假设当前的<code>activeEffect</code>是一个<code>update</code>渲染更新函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">activeEffect</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'渲染视图！'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这里是防止在触发setter的时候，没有这个options报错</span>
<span class="token comment">// 后面实现effect的时候，会用到这个选项</span>
activeEffect<span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>然后来创建一个组件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      num<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
      person<span class="token operator">:</span> <span class="token punctuation">{</span>
        a<span class="token operator">:</span> <span class="token number">1</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      state
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 模拟render访问数据的过程</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>num<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>person<span class="token punctuation">.</span>a<span class="token punctuation">)</span>

<span class="token comment">// 修改数据</span>
vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">666</span>
vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>person<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">999</span>
</code></pre></div><p>来看一下结果：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99eea96a04194f1caaf49461197d0216~tplv-k3u1fbpfcp-watermark.image" alt="sds.jpg"></p> <p>nice，组件中的数据成功的收集到了<code>effect</code>，并且在访问的时候能够触发。</p> <p>再来测试一个情况，假如深层对象的数据要是没有在<code>template</code>中被使用到，是否会被处理成响应式的呢？为了能准确的看到是哪个数据触发的更新，我们稍微改变一下原有的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 改变一下update函数</span>
<span class="token keyword">let</span> <span class="token function-variable function">activeEffect</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> --- 触发的更新视图！</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

activeEffect<span class="token punctuation">.</span>options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// trigger在执行effect的逻辑也稍微改一下</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>options<span class="token punctuation">.</span>scheduler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 传递当前的key的给update</span>
  <span class="token function">effect</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这里只单独的去访问num</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>num<span class="token punctuation">)</span>

<span class="token comment">// 修改数据</span>
vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">666</span>
vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>person<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">999</span>
</code></pre></div><p>再来看一下结果：</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/530b2644f11543529d3f75b03c65a50e~tplv-k3u1fbpfcp-watermark.image" alt="6sd8sd.png"></p> <p>非常的 nice，person 没有被访问，它并没有被响应式处理，所以不能触发<code>update</code>函数。</p> <h3 id="实现-dep"><a href="#实现-dep" class="header-anchor">#</a> 实现 Dep</h3> <p>Vue 中的三大重要素，已经实现了一个<code>Observer</code>，接下来我们实现用来存放订阅者的地方 --- Dep。</p> <p>在开始这个小节的时候，你首先得对<code>WeakMap, Map, Set</code>这几个数据结构有所了解。先来回顾一下 Vue2 是怎么存这个 Dep 的，在对象的每个 key 进行拦截处理的时候，在函数内部创建一个 dep，也就是将每一个 key 对应的 dep 保存在一个函数闭包中，大致实现如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在处理每个key的时候，在函数内部创建一个dep</span>
  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">observer</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 Vue3 中，我觉得 Dep 实现就比 Vue2 清晰简单很多。它其实就是几个数据结构。可以回看上面在实现 getter 的时候，用到的那几个变量<code>targetMap , depsMap , dep</code>。先来看这个 targetMap，其实它就是一个全局的<code>WeakMap</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> targetMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>这玩意是用来存数据对象（target）和 dep 集合（depsMap）对应关系的。就像代码中写的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> depsMap <span class="token operator">=</span> targetMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>depsMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果没有depsMap就创建一个</span>
  targetMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">(</span>depsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 每个key都有自己对应的dep</span>
<span class="token keyword">let</span> dep <span class="token operator">=</span> depsMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  depsMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span>dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当对一个对象使用<code>reactive</code>的时候，就会把当前这个对象的引用设为 targetMap 的一个键，然后创建一个新的 Map，也就是 depsMap，将其设为这个键的值。因为<code>WeakMap</code>的键是一个对象的引用，所以在后续的 getter 或者 setter 逻辑中直接通过 target 就能找到对应的 depsMap。所以你可以认为 targetMap 存的是一个<code>target -&gt; depsMap</code>的对应关系。</p> <p>那 depsMap 又是什么玩意？其实和<code>WeakMap</code>差不多，也是存的一个对应关系。在响应式原理中，一个 key 就对应这一个 dep，所以 depsMap 存的是对象所有的 key 和每个 key 对应 dep 的关系。在进行依赖收集的时候，会通过这个 target 找到对应的 depsMap，然后通过 key，来找到对应的 dep，最后在把当前的<code>activeEffect</code>存入 dep 中。</p> <p>下面我画了一个简单的示意图，具体关系如下：</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67b7cb85e54743968a201ca34478c430~tplv-k3u1fbpfcp-watermark.image" alt="niubi.jpg"></p> <h3 id="实现-effect"><a href="#实现-effect" class="header-anchor">#</a> 实现 effect</h3> <p>终于到了最后一个要素 --- 订阅者 effect。</p> <p>这也是 Vue3 响应式原理中，非常重要的一个角色。因为组件的很多工作都是靠订阅者的执行来驱动的。那这些订阅者具体是怎么工作的呢？</p> <h4 id="vue2-vue3-订阅者的区别"><a href="#vue2-vue3-订阅者的区别" class="header-anchor">#</a> Vue2 / Vue3 订阅者的区别</h4> <p>Vue2 的订阅者是通过<code>Watcher</code>这个类实现的，然后 Dep 这个类有一个 target 的静态属性，用来记录当前正在激活的 watcher。当创建 <code>Watcher</code>实例的时候，实例会将自身的引用赋值给这个 target，渲染过程中发生依赖收集的时候就会将当前的 Dep.target 收集进来。其实 Vue3 也是这个道理，就是<code>Watcher</code>变成了<code>effect</code>函数，Dep.target 变成了<code>activeEffect</code>这个变量。</p> <p>在 Vue3 中采用的 <code>effect</code> 函数，来实现订阅者。它允许你传入一个函数和一些配置项，并返回一个包装过的新函数。为了便于区分，我们把这个返回的新函数称为<code>reactiveEffect</code>。这个<code>reactiveEffect</code>执行时，会在不修改传入函数逻辑的情况下，扩展一个新的逻辑 --- 将自己身赋值给<code>activeEffect</code>。</p> <p>在 Vue3 中是这样为组件创建<code>effect</code>渲染函数的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// instance是组件实例</span>
instance<span class="token punctuation">.</span>update <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token comment">// 需要包装的渲染函数</span>
  <span class="token keyword">function</span> <span class="token function">componentEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'渲染组件'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// 创建完就立即执行</span>
    lazy<span class="token operator">:</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><p>当一个组件挂载的时候，会通过这个<code>effect</code>去包装渲染函数，生成一个<code>render effect</code>并立即执行它。<code>render effect</code>在执行<code>componentEffect</code>之前会将<code>activeEffect</code>指向这个自己。接着，在组件渲染过程中被访问的数据，就会收集到这个<code>activeEffect</code>，所以一旦数据更新，就能触发视图的渲染更新。</p> <p>那么这个<code>effect</code>函数是如何做到，在不侵入原来的代码的情况，加上额外逻辑的呢？</p> <h4 id="包装函数"><a href="#包装函数" class="header-anchor">#</a> 包装函数</h4> <p>首先讲一个概念 --- wrapper 函数。它是在函数式编程里面常用的一个编程手法。</p> <p>写一个普通的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'run'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在我需要这个函数在执行的时候，打印开始执行的时间，但是不能改原有函数的代码。此时，就可以使用 wrapper 函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 实现一个包装函数</span>
<span class="token keyword">function</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 写需要扩展的前置逻辑</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 得到一个新的函数</span>
<span class="token keyword">const</span> runAndPrintDate <span class="token operator">=</span> <span class="token function">wrapper</span><span class="token punctuation">(</span>run<span class="token punctuation">)</span>

<span class="token function">runAndPrintDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 输出结果：</span>
<span class="token comment">// Fri May 07 2021 16:22:52 GMT+0800 (中国标准时间)</span>
<span class="token comment">// run</span>
</code></pre></div><p>该方式就实现了既不修改原来函数的代码，又能扩展新的逻辑。其实<code>effect</code>函数实现的原理也是如此。</p> <h4 id="effect-实现"><a href="#effect-实现" class="header-anchor">#</a> effect 实现</h4> <p>effect 的具体实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// effect执行栈</span>
<span class="token keyword">const</span> effectStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token keyword">function</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建一个包装过的函数</span>
  <span class="token keyword">const</span> effect <span class="token operator">=</span> <span class="token function">createReactiveEffect</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token comment">// lazy可以决定是否立即执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">.</span>lazy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> effect
<span class="token punctuation">}</span>

<span class="token comment">// createReactiveEffect就是那个wrapper函数</span>
<span class="token keyword">function</span> <span class="token function">createReactiveEffect</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">effect</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">reactiveEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>effectStack<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 正在执行的effect推入执行栈</span>
        effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
        activeEffect <span class="token operator">=</span> effect
        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里希望执行完毕的effect退出执行栈</span>
        effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  effect<span class="token punctuation">.</span>id <span class="token operator">=</span> uid<span class="token operator">++</span>
  effect<span class="token punctuation">.</span>raw <span class="token operator">=</span> fn
  effect<span class="token punctuation">.</span>options <span class="token operator">=</span> options

  <span class="token keyword">return</span> effect
<span class="token punctuation">}</span>
</code></pre></div><p>以上代码有两个点要注意一下，分别是<code>effectStack</code>和<code>options</code>参数。</p> <p><code>effectStack</code>是一个记录<code>effect</code>的执行栈，它主要是解决一个<code>effect</code>嵌套调用的情况，这个概念在实现 computed 章节中会细说。</p> <p>重点来看<code>options</code>，因为在 Vue 中订阅者的类型有多种，它们在不同的应用场景会出现不同的需求，所以需要用一个<code>options</code>来配置不同的情况。就比如上面给组件实创建<code>render effect</code>的时候，就会配置一个<code>lazy</code>为 false 的属性。因为在组件初次挂载的时候，希望在创建<code>render effect</code>时马上执行去渲染 VNodeTree。但是有些场景，又不需要在创建的时候它马上执行，比如创建监听器或者计算属性的时候。但是，在<code>options</code>这个配置里面，最重要的还是<code>scheduler</code>这个属性。可以看到在<code>trigger</code>函数的执行中有一个很重要的步骤，就是在执行 dep 里面所有<code>effect</code>时，会判断是否有<code>scheduler</code>存在，如果有就是会使用<code>scheduler</code>去调度的执行。</p> <p>那为什么需要<code>scheduler</code>这种设计呢？我们重点看一下 Vue 中异步队列机制的实现。</p> <h2 id="实现异步队列的机制"><a href="#实现异步队列的机制" class="header-anchor">#</a> 实现异步队列的机制</h2> <p>咱们先不管异步队列机制是什么，先来看原先实现的代码有没有什么问题。来写一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      num<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
      person<span class="token operator">:</span> <span class="token punctuation">{</span>
        a<span class="token operator">:</span> <span class="token number">1</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      state
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 模拟组件挂载时生成的render effect</span>
<span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">componentEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模拟渲染过程中，访问值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>person<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'渲染组件'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    lazy<span class="token operator">:</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token comment">// 修改数据</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>person<span class="token punctuation">.</span>a <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>person<span class="token punctuation">.</span>a<span class="token operator">++</span>
<span class="token punctuation">}</span>

<span class="token comment">// 打印100次 “渲染组件”</span>
</code></pre></div><p>在这个例子中，修改了<code>state.person.a</code>这个变量 100 次，'渲染组件'就会被打印 100 次。要知道渲染组件其实有一个非常复杂的过程 --- patch。</p> <p>这过程会创建新的 VNodeTree，然后和旧的 VNodeTree 进行一个递归的比对，比对过程中会找出操作 dom 的最优方式，但是这个过程其实是比较麻烦的，它需要递归处理很多很多事情。如果每修改一次数据就执行一遍这个过程，其实是一种性能的浪费，那还不如直接操作 dom 来的快。</p> <p>那在 Vue 中是如何解决这个问题的呢？</p> <h3 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h3> <p>因为在 Vue 中有一种异步队列的机制，会把使用该机制的任务先缓存起来，等到所有数据都修改完毕，这些任务才会被执行。</p> <p>这种机制的核心就如它的名字，就是“队列”和“异步”。所谓“队列”，就是一个缓存任务的数组，所有通过这种机制调度执行的任务，会被缓存到队列中并且是去重的。至于“异步”就是执行数组中任务的方式，它会把一个执行“队列”里全部任务的方法推入微任务队列中，等到该轮宏任务执行完毕在执行，以此方式来保证所有的任务的“汇总”延后执行。那这种机制是如何具体实现的呢？</p> <p>先来实现一下缓存任务的过程：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 任务队列</span>
<span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token keyword">function</span> <span class="token function">queueJob</span><span class="token punctuation">(</span><span class="token parameter">job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
    <span class="token function">queueFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">queueFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 执行任务</span>
<span class="token punctuation">}</span>
</code></pre></div><p>缓存任务这个步骤搞定了，现在可以把这个<code>queueJob</code>赋值给<code>scheduler</code>了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 模拟组件挂载时生成的渲染effect</span>
<span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">componentEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'渲染组件'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    lazy<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    scheduler<span class="token operator">:</span> queueJob
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><p>这样在修改数据的时候，就会将当前这个<code>effect</code>先存入到队列里面，并还能保证每一个<code>effect</code>的唯一性。但是还有一个问题，在什么时机去执行<code>queue</code>的任务最合适呢？</p> <p>假如直接把<code>queueFlush</code>写成这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">queueFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 执行任务</span>
  queue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">job</span> <span class="token operator">=&gt;</span> <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那这个队列就毫无意义了，因为代码都是同步的原因，即使存了也是每次修改都会直接执行渲染，所以必须想办法让执行过程延后到所有赋值逻辑走完之后。这就得采用异步的方式，让渲染执行任务延后。那延迟到何时才是最好的呢？当然是当前宏任务执行完毕，开始执行微任务的时候。所以把执行时机放在微任务中是最好的。</p> <p>来改一下我们的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 任务队列</span>
<span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token comment">// 用来标记是否开启了一个微任务队列</span>
<span class="token keyword">let</span> isFlushPending <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token comment">// 用来标记queue中的任务是否正在执行</span>
<span class="token keyword">let</span> isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>

<span class="token keyword">function</span> <span class="token function">queueJob</span><span class="token punctuation">(</span><span class="token parameter">job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
    <span class="token function">queueFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">queueFlush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isFlushPending <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isFlushing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isFlushPending <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token comment">// 通过then方法将执行任务的方法（flushJobs）推入微任务队列</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>flushJobs<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 执行任务</span>
<span class="token keyword">function</span> <span class="token function">flushJobs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  isFlushPending <span class="token operator">=</span> <span class="token boolean">false</span>
  isFlushing <span class="token operator">=</span> <span class="token boolean">true</span>
  queue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">job</span> <span class="token operator">=&gt;</span> <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  queue<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
  isFlushing <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里来理一下上面的逻辑，假如在某一个交互事件中，改变了某个组件的很多个数据。这些数据对应的<code>trigger</code>逻辑都会触发，然后都使用<code>scheduler</code>去调度执行对应<code>effect</code>。此时第一个数据的修改执行了<code>queueJob</code>将该组件的<code>render effect</code>推入了任务队列<code>queue</code>中，然后执行<code>queueFlush</code>将任务刷新函数<code>flushJobs</code>推入微任务队列中，并进行一个标记，表示在微任务中已经推入了一个刷新任务的函数。这样第二次，乃至第 n 次数据的修改都不会把<code>flushJobs</code>推入到微任务中，而且<code>queue</code>中也只会有一个<code>render effect</code>。一旦本次宏任务执行完毕，根据 js 的事件循环机制，开始执行微任务，就把<code>flushJobs</code>压入执行栈中，这就是多次数据修改，只渲染一次的工作流程。</p> <p>这里来简单画一个流程图：</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b017dcb8481476d95478abf0d89f1ac~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG1607.png"></p> <p>这轮交互事件执行完毕，js 的执行栈开始向微任务队列拿任务执行，拿到<code>flushJobs</code>并执行，将<code>queue</code>中全部的任务执行完毕，整个异步更新的流程就走完了。</p> <h3 id="测试"><a href="#测试" class="header-anchor">#</a> 测试</h3> <p>这里改一下原来创建的 effect:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 模拟组件挂载时生成的渲染effect</span>
<span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">componentEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模拟渲染过程中，访问值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>person<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'渲染组件'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    lazy<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    scheduler<span class="token operator">:</span> queueJob
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><p>继续使用上面的例子来运行：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 修改值</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>person<span class="token punctuation">.</span>a <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>person<span class="token punctuation">.</span>a<span class="token operator">++</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结果：</p> <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7f53d97123d4eb688bae93b0cd97105~tplv-k3u1fbpfcp-watermark.image" alt="46136dbf5050f717b1bd3562137f6ae.png"></p> <p>非常 nice，就算这个值被改了 100 次，但是也只会渲染最后一次修改的状态。</p> <h2 id="实现-watch"><a href="#实现-watch" class="header-anchor">#</a> 实现 watch</h2> <p>在响应式原理中有说到，在渲染过程中数据可以自己去收集渲染函数<code>render effect</code>，一旦数据更新就会自动触发再次渲染。那有没有什么方法让我们手动去给某些数据增加事件，在数据变更的时候自动去执行呢？</p> <p>Watch 这个 API 就解决了这个需求。它允许我们去监听响应式的数据，然后在数据变更时执行回调。它是依赖于<code>effect</code>去实现的，因为被<code>effect</code>包装过的函数可以在执行前，将当前的<code>activeEffect</code>指向自己，所以通过<code>watch</code>创建的<code>watch effect</code>在执行时会对需要监听的值进行一次 get，这样被监听的数据就可以收集到这个<code>watch effect</code>，在数据变动时，就会触发<code>scheduler</code>中的回调。</p> <p>代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token parameter">getter<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> getter <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> _getter <span class="token operator">=</span> getter
  <span class="token keyword">let</span> oldValue

  <span class="token comment">/**
   * 执行回调
   * 计算新的值，缓存旧的值
   */</span>
  <span class="token keyword">function</span> <span class="token function">job</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> newValue <span class="token operator">=</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">callback</span><span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>
    oldValue <span class="token operator">=</span> newValue
  <span class="token punctuation">}</span>

  <span class="token comment">// 创建watch effect</span>
  <span class="token keyword">const</span> runner <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>_getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    lazy<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 异步调度的方式去执行</span>
      <span class="token function">queueJob</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  oldValue <span class="token operator">=</span> <span class="token function">runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>来测试一下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      num<span class="token operator">:</span> <span class="token number">100</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token function">watch</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>num<span class="token punctuation">,</span>
      <span class="token punctuation">(</span><span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'触发监听器'</span><span class="token punctuation">,</span> newVal<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      state
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 模拟组件挂载时生成的渲染effect</span>
<span class="token function">effect</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">componentEffect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 模拟渲染过程中，访问值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>num<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'渲染组件'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    lazy<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    scheduler<span class="token operator">:</span> queueJob
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

vm<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>state<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">200</span>
</code></pre></div><p>看一下结果：</p> <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e040e670a55d4fab953d9399036f7e79~tplv-k3u1fbpfcp-watermark.image" alt="4f8c08f76bb3b10046660d9e9e1f945.png"></p> <p>watch 的实现就搞定了。</p> <h2 id="实现-computed"><a href="#实现-computed" class="header-anchor">#</a> 实现 computed</h2> <p>计算属性这个 API 是 Vue 中的一个特色。它可以创建一个 computed 对象，然后内部的 value 可以根据依赖的数据进行计算获取得新的值，并触发页面的渲染。</p> <p>这次看一下完整的代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> _getter
  <span class="token keyword">let</span> _setter
  <span class="token keyword">let</span> _computed
  <span class="token keyword">let</span> _value
  <span class="token keyword">let</span> _dirty <span class="token operator">=</span> <span class="token boolean">true</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> options <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _getter <span class="token operator">=</span> options
    <span class="token function-variable function">_setter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'computed _ is readonly'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    _getter <span class="token operator">=</span> options<span class="token punctuation">.</span>get
    _setter <span class="token operator">=</span> options<span class="token punctuation">.</span>set
  <span class="token punctuation">}</span>

  <span class="token comment">// 创建computed effect</span>
  <span class="token keyword">let</span> runner <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span>_getter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    lazy<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">scheduler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当依赖的响应式数据发生变化</span>
        <span class="token comment">// 会将computed标记为脏值</span>
        _dirty <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token function">trigger</span><span class="token punctuation">(</span>_computed<span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  _computed <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果数据是脏才重新计算</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>_dirty<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        _value <span class="token operator">=</span> <span class="token function">runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        _dirty <span class="token operator">=</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
      <span class="token function">track</span><span class="token punctuation">(</span>_computed<span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> _value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">_setter</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> _computed
<span class="token punctuation">}</span>
</code></pre></div><p>computed 的原理和实现，可能理解起来会比较麻烦一点，也比较绕，所以这里我直接来讲已经写好的代码。上面的代码主要分为三个部分：标准化参数，创建 runner 函数，创建 computed 对象并返回。</p> <p>标准化参数就是将用户传入 getter 的不同情况做了处理，因为该 API 是允许用户传入一个单独的 getter，或者是一个包含 getter 和 setter 的对象的。这里我们重点来看 runner 函数，和创建的 computed 对象。</p> <h3 id="runner-函数"><a href="#runner-函数" class="header-anchor">#</a> runner 函数</h3> <p>runner 函数是对 getter 的封装。它执行时会改变<code>actvieEffect</code>指向自身，然后执行 getter 计算新的值，让 getter 函数内依赖的响应式数据收集到 runner。在这些数据变化时，会执行 runner 身上的 scheduler。</p> <h3 id="computed-对象"><a href="#computed-对象" class="header-anchor">#</a> computed 对象</h3> <p>这个对象维护了一个 value 值，当 computed 的 value 在渲染时被访问会发生什么呢？</p> <p>因为初始化的时候 dirty 默认是 true，所以会执行 runner 来计算新的值并且让 getter 中依赖的数据收集到 runner，接着是<code>track(_computed, 'value')</code>，让 computed 的 value 收集<code>actvieEffect</code>，因为访问 value 是发生在渲染过程中，所以 value 收集的是渲染函数<code>render effect</code>。</p> <p>现在有两个问题：</p> <ol><li>getter 中依赖的数据收集到 runner 的作用是什么</li> <li>为什么执行完 runner 后，computed 还能收集到 <code>render effect</code></li></ol> <p>第一个问题。当依赖的数据发生变化时会执行 runner 的 scheduler 中的逻辑，它是先将 dirty 标记为 true 来告诉 computed 这是一个脏值，并不会马上去重新计算新的值，并且会去触发渲染更新。等到再次渲染时访问到 computed 时，发现 dirty 是 true，就会重新进行计算。</p> <p>第二个问题。虽然 computed 的访问是发生在渲染过程中，当前的<code>actvieEffect</code>是<code>render effect</code>。但是执行 runner 的时候，runner 已经将当前的<code>actvieEffect</code>指向自己了，为什么后续的<code>track(_computed, 'value')</code>收集的是 <code>render effect</code>呢？</p> <p>因为对于这种<code>effect</code>嵌套使用的情况，Vue 设计了一个<code>effectStack</code>。可以在回看一下<code>effect</code>章节的代码:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>effectStack<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 正在执行的effect推入执行栈</span>
    effectStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
    activeEffect <span class="token operator">=</span> effect
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里希望执行完毕的effect退出执行栈</span>
    effectStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    activeEffect <span class="token operator">=</span> effectStack<span class="token punctuation">[</span>effectStack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>effect</code>的执行会把自己推入<code>effect</code>的执行栈并将<code>actvieEffect</code>指向自己，当它执行完后，就会将自己退出栈，并<code>actvieEffect</code>会执行指向栈顶，也就上一个<code>effect</code>。这个设计就很好解决了<code>effect</code>嵌套调用的情况。</p> <p>这里来假设一个情况。当 runner 执行完毕，如果没有将当前的<code>actvieEffect</code>退回到上一个<code>effect</code>，那在 computed 收集的时候就是收集到 runner 了。这就是一个错误的依赖收集，本来正常的逻辑应该是：依赖数据收集 runner，computed 收集渲染函数，这样依赖数据被修改才能告诉 computed，并触发 computed 收集到的渲染函数去重新渲染，但是由于 runner 执行完没有正确退出栈，就会导致 computed 没有渲染函数可以触发。</p> <h2 id="实现-watcheffect"><a href="#实现-watcheffect" class="header-anchor">#</a> 实现 watchEffect</h2> <p>watchEffect 的实现就相对比较简单了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">effect</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    scheduler<span class="token operator">:</span> queueJob
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这 API 更像是<code>effect</code>的一个封装，它会立即执行传入进来的回调函数，如果回调函数中有使用到响应式的数据，这些数据就会收集到这个<code>watchEffect</code>，数据变更就触发执行它。</p> <h2 id="最后"><a href="#最后" class="header-anchor">#</a> 最后</h2> <p>第一次写这种超长篇的文章 😂。感觉自己在逻辑梳理上还是有很多欠缺，可能里面有些东西讲的也不是很清楚，如果啥说的不对，或者讲的不是很清楚，希望大佬们能在评论区指点一下。如果对你稍微有那么一点点帮助的话，能否点赞关注一波，我会继续努力的。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/tangmouren/Vue/vue3组件通信.html" class="prev">
        vue3组件通信
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/tangmouren/assets/js/app.398b06f8.js" defer></script><script src="/tangmouren/assets/js/2.f18c010c.js" defer></script><script src="/tangmouren/assets/js/11.4dd24b27.js" defer></script>
  </body>
</html>
